
## spring framework란
- 자바 개발을 편리하게 해주는 오픈소스 프레임워크


## spring boot와 spring framework의 차이점
- spring은 프로젝트 초기에 다양한 환경설정을 해야 한다
- spring boot는 설정의 많은 부분을 자동화하여 사용자가 편하게 스프링을 활용할 수 있도록 도와준다
- spring boot starter에 dependency 라이브러리만 추가해주면 설정은 끝나고
- 내장된 톰캣을 통해 서버를 바로 실행할 수 있다

## spring mvc란
- MVC는 Model, View, Controller의 약자이다
- 각 레이어간 기능을 구분하는데 중점을 둔 디자인 패턴이다
- Model은 데이터 관리 및 비즈니스 로직을 처리한다 (DAO , DTO, Service 등)
- Controller는 사용자의 요청을 처리하고 Model과 View를 중개하는 역할을 한다


## mvc가 어떤 흐름으로 요청을 처리하는 가
1. 클라이언트는 URL을 통해 요청을 전송한다
2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어떤 컨트롤러에게 온것인지 찾는다
3. 핸들러 어덥태에게 요청을 처리를 맡긴다
4. 핸들러 어댑터는 해당 컨트롤러에게 요청을 전달한다
5. 컨트롤러는 비즈니스 로직을 처리한 후에 뷰의 이름을 반환해 준다
6. 디스패처 서블릿은 뷰 맂로버를 통해 반환할 뷰를 찾는다
7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가한다
8. 데이터가 추가된 뷰를 화면단으로 반환해준다

## IoC란 무엇인가
- 객체를 생성 및 관리하고 의존성을 관리해주는 컨테이너
- 객체 생성부터 소멸까지의 생명주기 관리를 컨테이너가 대신 해준다
- 객체 관리의 주체가 스프링 컨테이너가 되기 때문에 개발자는 로직에 집중할 수 있게 된다

## DI란 무엇인가
- 필요한 객체를 외부로 부터 주입받아 사용하는 것
- 객체간 결합도를 줄인다
- 의존성 주입에는 생성자 주입 , 필드 주입, 세터 주입의 3가지 방법이 있다
- spring에서 가장 권장하는 방법은 생성자를 통한 주입 방법이다

### 생성자 주입을 권장하는 이유
- 순환 참조를 방지할 수 있다
- 생성자로 의존성을 주입할 때 final로 선언할 수 있고, 이로인해 런타임에서 의존성을 주입받는 객체가 변할 일이 없어지게 된다
- 테스트 코드를 좀 더 편리하게 작성할 수 있다




## spring 빈 라이프사이클
- Bean 객체의 생명주기는 해당 객체가 언제, 어떻게 생성되어 소멸되기 전까지 어떤 작업을 수행하고 언제, 어떻게 소멸되는지 위와 같은 일련의 과정을 이르는 말
- spring 컨테이너가 초기화될 때 Bean 객체들을 등록, 생성, 주입하고 종료할 때 Bean 객체들을 소멸시키면서 생명 주기를 관리한다
1. 자바 코드, 어노테이션, XML 등)으로 설정 파일을 읽어서 Bean 객체를 생성한다
2. 프로퍼티 설정 파일을 읽어서 해당되는 Bean 객체에 의존성을 주입 한다
3. 등록된 Bean 객체는 필요한 곳에서 사용되다가 컨테이너가 종료되면 객체가 소멸 된다




## JPA N + 1문제가 발생하는 이유와 해결하는 방법
- N + 1이란 1번의 쿼리를 날렸는데 의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것을 의미한다
- 주로 JPA Repository를 통해 인터페이스 메서도를 호출할 때 (Read) 발생한다
  - JPA Repository로 find 시 실행하는 첫 쿼리에서 하위 엔티티까지 한 번에 가져오지 않고, 하위 엔티티를 사용할 때 추가로 조회하기 때문에 발생
- 해결방법으로 Fetch Join을 사용하여 해결할 수 있다
- 미리 두개의 테이블을 Join하여 한 번에 모든 데이터를 가져오기 때문에 N + 1문제를 막을 수 있다

### EAGER(즉시 로딩)인 경우
1. JPQL에서 만든 SQL을 통해 데이터를 조회
2. 이후 JPA에서 Fetch 전략을 가지고 해당 데이터의 연관 관계인 하위 엔티티들을 추가 조회
3. 2번 과정으로 N + 1 문제 발생
 
### LAZY(지연 로딩)인 경우
1. JPQL에서 만든 SQL을 통해 데이터를 조회
2. JPA에서 Fetch 전략을 가지지만, 지연 로딩이기 때문에 추가 조회는 하지 않음
3. 하지만, 하위 엔티티를 가지고 작업하게 되면 추가 조회가 발생하기 때문에 결국 N + 1 문제 발생


## REST란
- 웹의 장점을 최대한 활용할 수 있는 아키텍처이다
- 자원 , 행위 , 표현으로 구성되어 있다

## RESTFUL하다 란
- 리소스와 행위는 명시적이고 직관적으로 분리하는 방식으로 API를 설계하는것

### RESTful API 설계
- URI 는 정보의 자원을 표현해야한다(리소스명은 동사보다는 명사를 사용)
- 자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE 등)으로 표현
- 주의할 점
1. 슬래시 구분자(/)는 계층 관계를 나타내는데 사용한다
2. URI 마지막 문자로 슬래시(/)를 포함하지 않는다
3. 하이픈(-)은 URI 가독성을 높이는데 사용한다
4. 밑줄(_)은 URI 에 사용하지 않는다
5. URI 경로에는 소문자가 적합하다
6. 파일확장자는 URI 에 포함하지 않는다

### spring을 사용하는 이유
+ 스프링의 핵심 컨켑이 객체지향이다
+ 좋은 객체지향 애플리케이션을 개발할 수 있도록 도와주기 때문이다




### spring boot에서 내장형 톰캣 외 사용할 수 있는 서버 종류
+ Netty :  Async, Event-Driven 방식 네트워크 애플리케이션 프레임워크
  + Spring Boot 2 부터 Webflux Framework를 사용해서 Reactive Programming을 할 수 있다
  + 바로 이 Webflux를 사용하면 기본 내장 WAS는 Netty가 된다
+ Jetty : 적은 메모리를 사용하고 가볍고 속도가 빠르다, 하지만 대규모 트래픽에 취약하다
+ Undertow : Blocking과 Non-Blocking API를 모두 안정적으로 제공하는 유연한 고성능 웹서버
   + 대규모 트래픽으로부터 Tomcat보다 안정적이라고 평가 받는다
